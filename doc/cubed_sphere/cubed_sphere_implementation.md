
# Cubed-Sphere Grid Implementation

This document outlines the changes made to the project to support the cubed-sphere grid.

## New `utils/cubed_sphere` Directory

The `utils/cubed_sphere` directory has been added to house the core components for handling the cubed-sphere geometry.

### `cubed_sphere.py`

This file defines the `CubedSphere` class. Its key responsibilities include:

- **Grid Generation**: Creates the cubed-sphere grid geometry based on the specified number of elements per panel (`num_elem`).
- **Coordinate Transformations**: Provides methods to convert between different coordinate systems:
  - Local panel coordinates (`xi`, `eta`)
  - Gnomonic projected coordinates (`X`, `Y`)
  - 3D Cartesian coordinates (`Xc`, `Yc`, `Zc`)
  - Spherical coordinates (`lat`, `lon`)
- **Wind Vector Transformation**: Includes functions (`contra2wind` and `wind2contra`) to transform wind vectors between the model's computational grid (contravariant winds) and physical winds (zonal and meridional).

### `linear_cubed_sphere_interpolator.py`

This file contains the `LinearCubedSphereInterpolator` class, which resamples data from the original lat-lon grid to the new cubed-sphere grid using bilinear interpolation.

## Data Preprocessing Script (`scripts/preprocess_weatherbench_data_cubed_sphere.py`)

This script is a modified version of the original `preprocess_weatherbench_data.py` script, adapted to generate data on the cubed-sphere grid. The key changes are:

- **New Command-Line Argument**: A new argument, `-n` or `--num_elem_cs`, has been added to specify the number of elements for the cubed-sphere grid.
- **Cubed-Sphere Integration**: The script imports and utilizes the `CubedSphere` and `LinearCubedSphereInterpolator` classes.
- **Data Resampling**: In the `stack_data` function, the script interpolates the data from the lat-lon grid to the cubed-sphere grid using the `LinearCubedSphereInterpolator`.
- **New Data Structure**: The output Zarr files now have the `latitude` and `longitude` dimensions replaced by `panel_id`, `xi`, and `eta`. The data shape is now `(time, panel_id, xi, eta, features)`.


## TODO: 

- Adapt the Data Loading Pipeline

  The data pipeline needs to be updated to handle the new data format.


   * `data/era5_dataset.py`: Modify the torch.utils.data.Dataset implementation to load the Zarr files generated by your new script. It should now handle data with dimensions (time, panel_id, xi, eta, features).
   * `data/datamodule.py`: The LightningDataModule will need to be adjusted to work with the updated era5_dataset.py. The batch shape will change.

- Modify the Model Architecture

  The model needs to be adapted to the cubed-sphere geometry.

   * Input Shape: The model's input layer in model/paradis.py must accept the new tensor shape. We could merge the batch and panel dimensions. For example, an input tensor of shape (batch, features, panel_id, xi, eta) would be reshaped
     to (batch * panel_id, features, xi, eta) before being passed to the 2D convolutional layers.
   * For the diffusion: Cubed-Sphere Padding: We need to implement a "halo exchange" mechanism that passes data between the
     edges of adjacent cube panels.
   * For Semi-lagrangian: We need to update code to interpolate on the cubed sphere. We need to think about what to do for vectors 


- Handle Wind Components
  It might be best to work with wind components in local panel coordinates.

  - Convert to Contravariant Winds: In preprocess, use `wind2contra` to convert the physical winds (zonal u, meridional v) into contravariant winds (u1, u2) for each panel. What about the vertical?
  - Model Prediction: The model will learn to predict the u1 and u2 components.
  - Convert Back to Physical Winds: In post-processing and forecasting steps, convert the model's output back to physical u and v winds for analysis and visualization.

- Adjust the Loss Function
  
- Update Forecasting and Visualization

- Improve interpolation? Do we need bicubic? Do we need conservative scheme like [(1)](https://journals.ametsoc.org/view/journals/mwre/137/6/2008mwr2817.1.xml) [(2)](https://gmd.copernicus.org/preprints/8/4979/2015/gmdd-8-4979-2015.pdf). Maybe use [xesmf](https://xesmf.readthedocs.io/en/stable/notebooks/Dataset.html) package for re-gridding


## Appendix: Cubed-Sphere

The grid is constructed by projecting the six faces of a cube onto the surface of a sphere. This results in six logical panels that cover the sphere with a more uniform grid spacing, particularly near the poles.

### Global Grid Orientation

The cubed-sphere is composed of six panels, arranged as follows:

```
      +---+
      | 4 |
  +---+---+---+---+
  | 3 | 0 | 1 | 2 |
  +---+---+---+---+
      | 5 |
      +---+
```

Each panel is defined by a set of three orthogonal basis vectors in 3D Cartesian space: a **center** vector pointing from the origin to the panel's center, an **up** vector, and a **right** vector. For an un-rotated grid, these are:

| Panel | Center ($\mathbf{c}$) | Up ($\mathbf{u}$) | Right ($\mathbf{r}$) |
| :---: | :---: | :---: | :---: |
| 0 | (1, 0, 0) | (0, 0, 1) | (0, -1, 0) |
| 1 | (0, 1, 0) | (0, 0, 1) | (1, 0, 0) |
| 2 | (-1, 0, 0) | (0, 0, 1) | (0, 1, 0) |
| 3 | (0, -1, 0) | (0, 0, 1) | (-1, 0, 0) |
| 4 | (0, 0, 1) | (-1, 0, 0) | (0, -1, 0) |
| 5 | (0, 0, -1) | (1, 0, 0) | (0, 1, 0) |

The __right__ vector can derived from the cross product: $\mathbf{r} = \mathbf{u} \times \mathbf{c}$.

The entire cubed-sphere grid can be rotated to align with different geographical features. This is controlled by three angles passed during initialization: $\lambda_0$, $\phi_0$, and $\alpha_0$. These parameters define the orientation of the grid's panel 0:

- $\lambda_0$: Longitude of the center point of panel 0. 
- $\phi_0$: Latitude of the center point of panel 0. 
- $\alpha_0$: Rotation of the central meridian of panel 0 with respect to true north.

The cube can match this orientation by using the rotation $R = R_z(\lambda_0) \cdot R_y(-\phi_0) \cdot R_x(-\alpha_0)$ where $R_a$ is a rotation around the axis $a$.

Using this rotation on the base vectors $\mathbf{c}, \mathbf{u}$ and $\mathbf{r}$, we get the rotated panel vectors: $\mathbf{c'} = R\mathbf{c}$, $\mathbf{u'} = R\mathbf{u}$, and $\mathbf{r'} = R\mathbf{r}$ corresponding to rotated cube.



### Coordinate Systems

To map points from a panel's local grid to the globe, we use a chain of four different coordinate systems. The transformations between them are detailed below.

1. Equiangular (Local/Computational) Coordinates ($\xi, \eta$)

This is defined on the flat, square face of the cube before it's projected. The coordinates $\xi$ and $\eta$ represent the angle of a point from the center of the panel, as viewed from the center of the sphere. Both $\xi$ and $\eta$ range from $-\pi/4$ to $\pi/4$.

- **$\xi$**: The left-right angular coordinate.
- **$\eta$**: The down-up angular coordinate.

These directions are with respect to the $\mathbf{u'}$ and $\mathbf{r'}$ orientation.

We use a uniform grid in ($\xi, \eta$) on each panel.

2. Gnomonic Coordinates ($X, Y$)

The gnomonic projection maps points from the sphere's center onto a plane that is tangent to the sphere at the center of a panel. This projection has the useful property that all great circles on the sphere appear as straight lines on the tangent plane.

3. 3D Cartesian Coordinates ($X_c, Y_c, Z_c$)

These are the standard $(x, y, z)$ coordinates in 3D space, assuming the sphere is a unit sphere centered at the origin $(0, 0, 0)$.

4. Spherical Coordinates ($\phi$, $\lambda$)

These are the standard geographic coordinates: latitude ($\phi$) and longitude ($\lambda$).


### Coordinate Transformations

**Forward Transformation: From Local ($\xi, \eta$) to Spherical ($\phi$, $\lambda$)**

1.  **Local to Gnomonic**:
    $X = \tan(\xi), \ Y = \tan(\eta)$

2.  **Gnomonic to 3D Cartesian**: The 3D point $\mathbf{P} = (X_c, Y_c, Z_c)$ on the unit sphere is found by projecting the gnomonic coordinates back onto the sphere using the rotated panel vectors ($\mathbf{c'}, \mathbf{r'}, \mathbf{u'}$):
    $$\mathbf{P} = \frac{\mathbf{c'} + \mathbf{r'}X + \mathbf{u'}Y}{\delta}$$
    where $\delta = \sqrt{1 + X^2 + Y^2}$ is a normalization factor.

3.  **3D Cartesian to Spherical**:
    $\phi = \arcsin(Z_c), \ \lambda = \text{arctan2}(Y_c, X_c)$

**Inverse Transformation: From Spherical ($\phi$, $\lambda$) to Local ($\xi, \eta$)**

1.  **Spherical to 3D Cartesian**:
    $$\begin{aligned}
    X_c &= \cos(\phi) \cos(\lambda)\\
    Y_c &= \cos(\phi) \sin(\lambda)\\
    Z_c &= \sin(\phi)
    \end{aligned}$$
    This gives the point $\mathbf{P} = (X_c, Y_c, Z_c)$.

2.  **Find the Panel**: The correct panel for the point $\mathbf{P}$ is the one whose rotated center vector $\mathbf{c'}$ has the highest dot product with $\mathbf{P}$

3.  **3D Cartesian to Gnomonic**: Once the correct panel (and its vectors $\mathbf{c'}, \mathbf{r'}, \mathbf{u'}$) is identified, the point $\mathbf{P}$ is projected from the sphere onto the panel's tangent plane to find the gnomonic coordinates:
    $$X = \frac{\mathbf{P} \cdot \mathbf{r'}}{\mathbf{P} \cdot \mathbf{c'}}, \ Y = \frac{\mathbf{P} \cdot \mathbf{u'}}{\mathbf{P} \cdot \mathbf{c'}}$$

4.  **Gnomonic to Equiangular**:
    $\xi = \arctan(X), \ \eta = \arctan(Y)$

### Wind Transformation

The transformation of wind vectors from the local, contravariant basis on a panel to the physical, spherical coordinate system can be described using a chain of Jacobian matrices. The overall transformation is the product of the Jacobians for each intermediate coordinate conversion.

Let the wind vector in the local equiangular (contravariant) coordinates be $\mathbf{v}_\xi = (u_1, u_2)^T = (\dot{\xi}, \dot{\eta})^T$.
Let the wind vector in the gnomonic coordinates be $\mathbf{v}_g = (\dot{X}, \dot{Y})^T$.
Let the wind vector in the 3D Cartesian coordinates be $\mathbf{v}_c = (\dot{X_c}, \dot{Y_c}, \dot{Z_c})^T$.
Let the wind vector in the spherical coordinates be $\mathbf{v}_s = (\dot{\lambda}, \dot{\phi})^T$.
Let the physical wind vector be $\mathbf{v}_p = (u, v)^T$.

The transformation can be expressed as:
$\mathbf{v}_p = \mathbf{J}_{s \to p} \mathbf{J}_{c \to s} \mathbf{J}_{g \to c} \mathbf{J}_{\xi \to g} \mathbf{v}_\xi$ and 
$\mathbf{v}_\xi =\mathbf{J}_{g \to \xi} \mathbf{J}_{c \to g} \mathbf{J}_{s \to c} \mathbf{J}_{p \to s} \mathbf{v}_p$

In general, $\mathbf{J}_{a \to b} = \mathbf{J}_{b \to a}^{-1}$

1. Between Contravariant and Gnomonic ($\mathbf{J}_{\xi \to g}, \mathbf{J}_{g \to \xi}$)

The coordinate transformation is:
$X = \tan(\xi), \quad Y = \tan(\eta)$

The Jacobian of this transformation, $\mathbf{J}_{\xi \to g}$, is:
$$\mathbf{J}_{\xi \to g} = \begin{pmatrix} \frac{\partial X}{\partial \xi} & \frac{\partial X}{\partial \eta} \\ \frac{\partial Y}{\partial \xi} & \frac{\partial Y}{\partial \eta} \end{pmatrix} = \begin{pmatrix} \sec^2(\xi) & 0 \\ 0 & \sec^2(\eta) \end{pmatrix} = \begin{pmatrix} 1+X^2 & 0 \\ 0 & 1+Y^2 \end{pmatrix}$$
and 
$$\mathbf{J}_{g \to \xi} = \begin{pmatrix} \frac{1}{1+X^2} & 0 \\ 0 & \frac{1}{1+Y^2} \end{pmatrix}$$

2. Between Gnomonic and 3D Cartesian ($\mathbf{J}_{g \to c}$, $\mathbf{J}_{c \to g}$)

The coordinate transformation is:
$\mathbf{P} = (X_c, Y_c, Z_c)^T = \frac{\mathbf{c'} + \mathbf{r'}X + \mathbf{u'}Y}{\delta}$
where $\delta = \sqrt{1 + X^2 + Y^2}$.

The Jacobian, $\mathbf{J}_{g \to c}$, is a 3x2 matrix:
$$
\mathbf{J}_{g \to c} = \begin{pmatrix} \frac{\partial X_c}{\partial X} & \frac{\partial X_c}{\partial Y} \\ \frac{\partial Y_c}{\partial X} & \frac{\partial Y_c}{\partial Y} \\ \frac{\partial Z_c}{\partial X} & \frac{\partial Z_c}{\partial Y} \end{pmatrix} = \begin{pmatrix} \frac{\partial \mathbf{P}}{\partial X}& \frac{\partial \mathbf{P}}{\partial Y} \end{pmatrix}
$$

The partial derivatives are found by differentiating $\mathbf{P}$:
$$
\frac{\partial \mathbf{P}}{\partial X} = \frac{\mathbf{r'} \delta - (\mathbf{c'} + \mathbf{r'}X + \mathbf{u'}Y) \frac{X}{\delta}}{\delta^2} = \frac{\mathbf{r'}(1+Y^2) - X(\mathbf{c'} + \mathbf{u'}Y)}{\delta^3}
$$

Similarly:
$$
\frac{\partial \mathbf{P}}{\partial Y} = \frac{\mathbf{u'}(1+X^2) - Y(\mathbf{c'} + \mathbf{r'}X)}{\delta^3}
$$


From the inverse coordinate transformation, we have:
$X = \frac{\mathbf{P} \cdot \mathbf{r'}}{\mathbf{P} \cdot \mathbf{c'}}, \quad Y = \frac{\mathbf{P} \cdot \mathbf{u'}}{\mathbf{P} \cdot \mathbf{c'}}$
The Jacobian, $\mathbf{J}_{c \to g}$, is a 2x3 matrix:
$$
\mathbf{J}_{c \to g} = \begin{pmatrix} \frac{\partial X}{\partial X_c} & \frac{\partial X}{\partial Y_c} & \frac{\partial X}{\partial Z_c} \\ \frac{\partial Y}{\partial X_c} & \frac{\partial Y}{\partial Y_c} & \frac{\partial Y}{\partial Z_c} \end{pmatrix} = \begin{pmatrix} \frac{\partial X}{\partial \mathbf{P}} \\ \frac{\partial Y}{\partial \mathbf{P}} \end{pmatrix}
$$

$$\frac{\partial X}{\partial \mathbf{P} } = \frac{\mathbf{r'} (\mathbf{P}.\mathbf{c'}) - \mathbf{c} (\mathbf{P}.\mathbf{r'})}{(\mathbf{P}.\mathbf{c'})^2} = \frac{\mathbf{r'} - X \mathbf{c'}}{\mathbf{P}.\mathbf{c'}}$$
$$\frac{\partial Y}{\partial \mathbf{P} } = \frac{\mathbf{u'} (\mathbf{P}.\mathbf{c'}) - \mathbf{c} (\mathbf{P}.\mathbf{u'})}{(\mathbf{P}.\mathbf{c'})^2} = \frac{\mathbf{u'} - Y \mathbf{c'}}{\mathbf{P}.\mathbf{c'}}$$

Note that $\mathbf{P}.\mathbf{c'} = \frac{1}{\delta}$
Therefore: 
$\mathbf{J}_{c \to g} = \delta \begin{pmatrix} \mathbf{r'} - X \mathbf{c'} & \mathbf{u'} - Y \mathbf{c'} \end{pmatrix}$

3. Between 3D Cartesian and Spherical ($\mathbf{J}_{c \to s}$, $\mathbf{J}_{s \to c}$)

The coordinate transformation is:
    $$\begin{aligned}
    X_c &= \cos(\phi) \cos(\lambda)\\
    Y_c &= \cos(\phi) \sin(\lambda)\\
    Z_c &= \sin(\phi)
    \end{aligned}$$

This gives the 3x2 Jacobian:
$\mathbf{J}_{s \to c} = \begin{pmatrix} \frac{\partial X_c}{\partial \phi} & \frac{\partial X_c}{\partial \lambda} \\
\frac{\partial Y_c}{\partial \phi} & \frac{\partial Y_c}{\partial \lambda} \\
\frac{\partial Z_c}{\partial \phi} & \frac{\partial Z_c}{\partial \lambda} \end{pmatrix} = \begin{pmatrix} -\sin(\phi) \cos(\lambda) & -\cos(\phi) \sin(\lambda)\\
-\sin(\phi) \sin(\lambda) & \cos(\phi) \cos(\lambda) \\
\cos(\phi) & 0 \end{pmatrix}$

For the transformation from cartesian to spherical, we have:
$\phi = \arcsin(Z_c), \quad \lambda = \arctan2(Y_c, X_c)$

This gives the 2x3 Jacobian
$$
\mathbf{J}_{c \to s} = \begin{pmatrix} 
0 & 0 & \frac{1}{\cos(\phi)}\\
-\frac{\sin(\lambda)}{\cos(\phi)} & \frac{\cos(\lambda)}{\cos(\phi)} & 0  
 \end{pmatrix}
$$



4. Between Spherical and Physical ($\mathbf{J}_{s \to p}$, $\mathbf{J}_{p \to s}$)

This final step is between angular velocities (rad/s) and physical velocities (m/s) using the Earth's radius ($R_e$).

$u$ is the east-west (zonal) component of velocity along a circle of latitude. These circle have radius $R_e \cos(\phi)$.
$v$ is the north-south (meridional) component of velocity along a circle of longitude. These circle have radius $R_e$.
Therefore the transformation is:
$u = \dot{\lambda} R_e \cos(\phi), \quad v = \dot{\phi} R_e$ and 
$\mathbf{J}_{s \to p} = \begin{pmatrix} R_e \cos(\phi) & 0 \\ 0 & R_e \end{pmatrix}$
$\mathbf{J}_{p \to s} = \begin{pmatrix} \frac{1}{R_e \cos(\phi)} & 0 \\ 0 & \frac{1}{R_e} \end{pmatrix}$

